# System Architecture Specification (Current v1)

## Purpose

This document describes the architecture currently implemented in this repository.
It is implementation-first and avoids future-state assumptions.

## Scope And Status

### Implemented In Current Web App

- Responsive React + Vite + Tailwind web client.
- FastAPI backend with REST and WebSocket APIs.
- Guest browsing and cart operations.
- Authentication required before order creation.
- Guest cart/session continuity into authenticated account.
- Conversational orchestration pipeline (rule-first with optional LLM assist).
- User preference memory and interaction-history fallback.
- Admin APIs for catalog, inventory, support, and voice controls.
- SuperU-based abandoned-cart outbound voice recovery pipeline (guardrailed).
- Core security hardening and Prometheus metrics.

### Deferred

- Native mobile app shell.
- Native kiosk app shell.
- Production payment gateway integration (current payment flow is token-stubbed).
- Compliance and regulatory workflow automation.

## Architecture Overview

```text
[Web Client: React/Vite/Tailwind]
           |
           | HTTP (REST) + WebSocket
           v
[FastAPI Application Layer]
  - Routes: auth/products/cart/orders/sessions/interactions/memory/admin/voice-callback
  - WebSocket endpoint: /ws
  - Middleware: hardening, rate-limit, security headers, metrics, persistence trigger
           |
           v
[Orchestrator Layer]
  - IntentClassifier (rules first, optional LLM refinement)
  - ContextBuilder
  - ActionExtractor
  - AgentRouter
  - ResponseFormatter
           |
           v
[Agents]
  - ProductAgent
  - CartAgent
  - OrderAgent
  - SupportAgent
  - MemoryAgent
           |
           v
[Service + Repository Layer]
  - Auth / Session / Cart / Order / Memory / Interaction / Support / Voice / Admin services
  - Repositories with in-memory store + optional Mongo/Redis adapters
           |
           v
[Infrastructure Integrations]
  - LLM client (OpenAI or Anthropic)
  - SuperU client
  - Rate limiter
  - Metrics collector
  - State persistence manager
```

## Layer Details

### 1) Client Layer

- Single responsive web experience (`frontend/src/App.tsx`).
- Local persistence of access token and `sessionId` in browser storage.
- Product catalog + product detail route (`/products/{id}`).
- Chat UI over WebSocket with reconnect, typing events, and streaming deltas.

### 2) API Layer

- REST namespace: `/v1/*`.
- WebSocket endpoint: `/ws`.
- Session resolution via `X-Session-Id` or `session_id` cookie.
- Order creation requires authenticated user + `Idempotency-Key`.

### 3) Orchestration Layer

- Rule-first intent classification always runs.
- Optional LLM classification may override when confidence is higher.
- Context includes session, cart, and (for authenticated users) memory snapshot.
- Agents execute extracted actions and return structured payloads.

### 4) Domain/Agent Layer

- Product operations: search/filter/recommendation response building.
- Cart operations: add/remove/update/clear, quantity adjustment, discount apply.
- Order operations: checkout summary, status, cancel/refund/address update.
- Support operations: ticket escalation/status/close flows.
- Memory operations: save/show/forget/clear preference memory.

### 5) Data/Persistence Layer

- In-memory store is the default runtime source of truth.
- Optional external persistence (`ENABLE_EXTERNAL_SERVICES=true`) enables Mongo/Redis-backed repository and snapshot persistence behavior.
- Session TTL: 30 minutes of inactivity.
- Cart TTL: 24 hours (status transitions include `active`, `abandoned`, `converted`).

## Core Runtime Flows

### Guest Browse/Cart To Authenticated Checkout

1. Guest session is created and cart operations are allowed.
2. User registers/logs in.
3. Guest cart merges into user cart (`productId + variantId` merge key).
4. Session resolves to account-linked active session.
5. Order creation is now allowed (auth + idempotency required).

### Conversational Message Processing

1. Message arrives from REST `/interactions/message` or WebSocket `/ws`.
2. Intent is classified (rules first, optional LLM).
3. Context is built from session + cart + memory.
4. Actions are extracted and routed to target agent(s).
5. Agent response is formatted for transport.
6. Interaction is recorded; session conversation state is updated.
7. Memory update runs asynchronously for authenticated users.

### Cross-Channel Continuity (Current Behavior)

- Session continuity is account-linked via `resolve_user_session(...)`.
- On authenticated requests, backend can reuse latest active user session.
- This supports continuity across channel surfaces that share backend contracts (current web and future channels).

### Voice Recovery Processing

1. Background scheduler and/or admin trigger scans abandoned carts.
2. Jobs are queued and processed with retry backoff.
3. Guardrails enforce quiet hours, per-user/day caps, and budget limits.
4. Outbound call is initiated through SuperU when enabled/configured.
5. Signed webhook callbacks update outcomes and trigger follow-up actions.

## Cross-Cutting Controls

### Security

- JWT auth (HS256), role checks for admin routes.
- Request hardening (size cap, JSON content-type enforcement, duplicate critical header rejection).
- Per-tier rate limiting (anonymous/authenticated/admin).
- WebSocket origin checks.
- Signed SuperU callback verification.

### Observability

- `/health` exposes service and runtime subsystem status.
- `/metrics` exports Prometheus counters/histograms.
- Admin activity logging includes tamper-evident integrity verification endpoint.

## Known Architectural Constraints

- Native mobile and kiosk clients are not yet implemented.
- Payment authorization is stubbed and not connected to an external processor.
- Compliance requirements are explicitly out of current scope.
